## 4. 통합  

우리 문제 영역에서 *느슨한 결합*과 *높은 응집력*의 이중 혜택을 가져다주는 접합부를 어떻게 찾는지 배웠다.  
개발자에 의한 변경은 때로 서비스 소비자측의 변경까지 초래하는 결과를 가져올 수 있지만, 가능하면 이러한 변경을 일으키지 않는 기술을 선택하고 싶을 것이다.   
서비스 통합에 필요한 좋은 기술을 선택하는 데 도움이 되는 몇 가지 지침이 있다.

> 고객 생성은 단순한 CRUD 명령의 집합으로 간주될 수 있다.  
> 하지만 대부분의 시스템에서 그렇게 단순한 작업은 아니다.  
> 새로운 고객이 등록되면 금융 결제 또는 환영 이메일과 같은 부가적인 프로세스를 시작해야 하고,  
> 고객 정보를 변경하거나 삭제할 때는 또 다른 비즈니스 프로세스가 작동할 수 있다.  

DB는 사실상 공유된 매우 큰 API로서 상당히 깨지기 쉬워, 대개 대규모의 회귀 테스트가 필요  
시간이 지나도 서비스 내부 변경 방식에 관한 자율성을 서비스에 줄 수 있도록  
소비자에게 서비스의 세부 구현이 은폐되기를 진심으로 원한다.  
그렇지 않으면 느슨한 결합과는 영영 이별이다.  

**좋은 마이크로서비스의 핵심 원칙은 강한 응집력과 느슨한 결합**    


### 동기 통신  
원격 서버에 대한 호출이 완료될 때까지 연산 작업이 중단    
- 언제 작업이 성공적으로 완료되었는지 알 수 있어서 추론하기 용이  
- 요청/응답 스타일  

### 요청/응답 스타일(request/response)  
동기 통신 방식과 명확히 일치하지만, 비동기 통신에서는 콜백을 활용하여 작동할 수 있음  

### 비동기 통신
호출자는 작업이 완료되었다는 회신을 기다리지 않으며, 심지어는 작업의 완료 여부에 관심이 없을 때도 있음  
- 클라이언트와 서버 간에 오랫동안 접속을 유지하기 어려운 장기 작업에 유용  
- 결과를 기다리는 동안 중단된 호출이 성능 저하를 일으키는 곳에서 짧은 지연시간이 필요할 때 적합  
- 이벤트 기반 협업  

### 이벤트 기반 협업  
- 클라이언트는 완료되어야 할 작업을 요청하는 대신 이벤트가 발생했음을 알리고 다른 당사자들이 무엇을 해야 할지 알기 기대함  
- 우리는 결코 다른 누구에게도 해야할 일을 말하지 않는 것  
- 결합도가 매우 낮은 방식  

### 오케스트레이션(orchestration) 방식   
오케스트라 지휘자처럼 프로세를 안내하고 구동하는 하나의 중앙 두뇌에 의존   
- 고객 서비스에 지나치게 많은 중앙 관리 권한이 부여되는 단점  
- 웹 중간에서 허브가 되어 로직이 살아나는 중심점이 될 수 있음  
- 이 방식은 빈약한 CRUD 기반의 서비스에 할 일을 지시하는 소수의 똑똑한 신과 같은 서비스를 낳음  

### 크레오그래피(choreography) 방식   
발레 무용수들이 자신의 역할을 주변의 다른 무용수에 반응하는 것처럼 시스템 각 부분에 작업 내용 내용을 알리고 세부 사항을 수행  
- 고객 서비스가 비동기 방식으로 고객이 생성되었다라는 이벤트를 발산할 뿐  
- 시스템에 암시적으로 반영되었다는 것  
- 모든 일이 제대로 수행되는지 모니터하고 추적하기 위한 추가 작업이 필요하다는 것을 의미  

분산 컴퓨팅에 대한 유명한 착오, 네트워크는 신뢰할 수 있다?! -> 네트워크는 신뢰할 수 없다!  
클라이언트와 서버가 정상이라 하더라도 네트워크는 실패할 수 있고, 심지어 패킷을 변형할 수 있음을 명심   

## REST - REpresentational State Transfer   

웹에서 영감을 얻은 아키텍쳐 방식으로 resource의 개념 이 가장 중요  
- 자원이 외부에 보여지는 방식과 내부에 저장되는 방식은 완전히 분리<sup id="fnref1"><a href="#fn1">1</a></sup>   
- HTTP가 동사(verb)처럼 스펙의 일부로 우리에게 제공하는 몇몇 기능은 HTTP상의 REST를 쉽게 구현할 수 있게 함  

### HTTP  

자체적으로 REST 방식과 궁합이 맞는 유용한 기능들을 정의  
- REST 아키텍처 방식은 실제로 메서드가 메서드가 모든 자원에 대해 같은 방식으로 동작  
- HTTP 사양서에는 우리가 사용할 수 있는 다수의 메서드가 정의 (GET/POST/PUT/DELETE 등)
- GET : 멱등 방식<sup id="fnref2"><a href="#fn2">2</a></sup>으로 자원을 추출  
- POST : 새로운 자원을 생성  
- JSON은 HTTP상에서 작동하는 대중적인 콘텐츠 타입  

### HATEOAS   

**H**ypermedia **A**s **T**he **E**ngine **O**f **A**pplication **S**tatus    
클라이언트와 서버가 결합하지 않게 도와주는 또 다른 원칙인 애플리케이션 상태 엔진  
- 클라이언트가 다른 자원에 대한 링크를 통해 서버와 (잠재적으로 상태 변이를 초래하는) 상호작용을 한다는 것  
- 어떤 URI를 요청했는지 알고 있으므로 서버 내 고객의 정확한 위치를 알 필요는 없음  
- 대신 클라이언트는 필요한 것을 발견하기 위해 링크를 찾고 탐색  

```    
HTTP는 대규모 트래픽에는 적합할 수 있지만 TCP 또는 다른 네트워킹 기술 기반의 대체 프로토콜과 비교하면  
낮은 지연시간이 필요한 통신에는 그다지 좋은 선택은 아님  
```  

### correlation ID/상관관계 ID  
적재적소에서 모니터링하고 프로세스 경계 요청을 추적할 수 있도록 상관관계 ID의 사용을 적극 검토   

---  


> 고객 정보 변경에 관한 결정이 고객 서비스 외부에서 이뤄진다면 응집력을 잃은 것   

### Rx(Reactive Extension)  
반응형 확장 라이브러리   
- Observer pattern에 기반을 두고 설계됨  
- 관찰 대상 순서를 이용하여 비동기 이벤트 기반의 반응형 프로그래밍을 지원하는 라이브러리  
- 다수의 호출 결과를 조회하고 그 결과에 따라 연산을 실행하는 메커니즘  
- 이들 호추른 그 자체로 blocking or nonblocking 호출이 될 수 있음  
- 하위 서비스에 대해 동시에 발생하는 호출들을 훨씬 쉽게 처리하면서 다수의 호출을 함께 조립할 수 있다는 것  

내부적으로 Rx는 전통적인 흐름을 뒤집음   
- 데이터를 요청하는 대신 데이터에 대한 연산을 수행, 그 연산(또는 연산의 집합)의 결과를 관찰, 변경에 따라 반응  
- 일부 Rx 구현제를 통해 관찰 대상의 함수를 수행 할 수 있음  
- RxJava에서는 map과 filter같은 전통적인 함수가 수행 될 수 있음  


> 여러분 시스템의 도처에 있는 중복된 행위를 변경하려 할 때 모든 것을 제대로 변경하기 어렵고 이는 버그로 이어질 수 있다.  
> 따라서 일반적으로 DRY를 기도문으로 사용하는 것도 일리가 있다.  


### DRY(Don't Repeat Yourself)  
중복된 코드를 회피하는 시도로 단순하게 정의되지만, 더 명확하게 정의하자면 시스템의 행동양식과 지식의 중복을 회피하는 모든 시도  
- 반드시 피해야 할 위험 중 하나는 마이크로서비스와 소비자 간의 지나친 결합  
- 마이크로서비스 자체의 작은 변경 사항 하나가 많은 소비자에게 불필요한 변경을 초래 할 수 있음  
- 공유 코드의 사용이 이러한 결합을 만듬  

공유 코드를 서비스 경계를 넘어서 사용한다면 잠재적인 결합의 문제를 안고 있는 셈  
- 하지만 로깅 라이브러리와 같은 공통 코드는 외부에서는 보이지 않는 내부의 개념이므로 사용해도 문제 없음  
- 코드를 공유하기보다는 결합이 생기지 않도록 그 템플릿을 새로운 서비스마다 복사  


### 클라이언트 라이브러리  
클라이언트 라이브러리의 업데이트 시점을 클라이언트가 담당하게 하라   
- 각 서비스를 항상 독립적으로 릴리스 할 능력을 유지해야 하기 때문  

### 포스텔의 법칙 - 견고성의 원칙  
서비스를 가능한 한 유연하게 소비하는 클라이언트를 만들려는 사례   
전송할 때는 보수적으로, 받아들일 때는 자유롭게  

### Semantic versioning  
유의적 버전 관리. 클라이언트가 서비스의 버전 번호만 보고도 해당 서비스와 통합 가능한지 알 수 있는 명세   
**MAJOR.MINOR.PATCH** 형태  
- MAJOR : 하위 호환성이 깨진 변경이 발생 했음  
- MINOR : 하위 호환성을 유지하면서 새로운 기능들이 추가되었음  
- PATCH : 기존 기능의 버그를 수정했다는 것을 의미  

### 다수의 병행 서비스 버전 사용하기  
다양한 버전의 서비스를 동시에 실행하고, 구 소비자의 트래픽을 구버전에, 신규 소비자의 신버전에 라우팅하는 것   
단점  
- 한 서비스의 내부 버그를 고치려면 두 벌의 서로 다른 서비스를 수정하고 배포해야 함  
- 소비자가 찾는 서비스로 유도하기 위한 부가적인 로직이 필요  
- 서비스가 처리해야할 영속적 상태가 있는지 고려  

### API Gateway  
클라이언트에 개별 서비스를 액세스할 수 있는 단일 접근 지점이 되어  
클라이언트의 요청을 적절히 해당 서비스로 라우팅하거나 다양한 서비스로 분배  
클라이언트에 최적화된 API를 제공하고, 클라이언트의 인증 및 접근 제어를 가능하게 함  

### UI 부분 구성  
큰 단위의 UI 부분은 서버 측 애플리케이션으로부터 제공, 적절한 API 호출을 수행  
UI 부분이 팀의 소유권과 완전히 일치할 때 가장 잘 작동  
예로, 뮤직 쇼핑몰에서 주문 관리를 담다하는 팀은 주문 관리와 연관된 모든 페이지를 구성해서 제공하는 것  
그러나 _사용자 경험의 일관성 유지는 풀어야할 숙제_  

### BFF(Backend for Frontend)  
특정 UI에 집중하는 팀이 해당 서버 측 컴포넌트도 담당  

### 퍼사드 패턴(facade pattern)   
외부에 대한 내부 콘텐트 서비스를 추상황하는 용도로 쓰임  
SOA 또는 Design Pattern에서는 이를 Service Facade 또는 Facade Pattern이라고 부름  
![위키백과 - 퍼사드 패턴](https://ko.wikipedia.org/wiki/%ED%8D%BC%EC%82%AC%EB%93%9C_%ED%8C%A8%ED%84%B4)  

### 다기능의 CRM 시스템  
고객 관계 관리는 대담 아키텍트의 마음에도 두렴을 불어넣는 자주 만나게 되는 야수  
세일즈포스 또는 SAP 등의 벤더로 대표되는 이 분야는 여러분을 위해 무엇이든 하려는 도구들로 가득하며  
그 자체가 단일 장애 지점이 되거나 의존성으로 얽힌 매듭이 될 수 있음  
많은 CRM 구현제는 응집되는 대응 의미로 고착되는 서비스를 잘 보여주는 사례  

RESTful 자원을 노출하여 프로젝트 정보를 제공하고, 외부 시스템은 작업하기 편한 이 새로운 프로젝트 서비스와 통합  
내부적으로 프로젝트 서비스는 파사드가 되어 하부의 세부적인 통합 내용을 감춤  

### 교살자 패턴  
완전한 통제권이 없는 레거시 플랫폼 또는 상용 플랫폼의 경우 이들을 제거하거나  
또는 그로부터 이전하려 할 때 발생하는 문제를 잘 처리해야 하며 이 때 사용되는 유용한 패턴  
CMS의 앞단을 자체 코드로 작성했더 사례와 흡사하게 교살자를 통해 구버전 시스템에 대한 호출을 잡아내 가로 챔  
교살자는 이 호출을 기존의 레거시 코드 또는 새로운 코드로 바로 경유할지 결정할 수 있음  
엄청난 분량의 코드 재작성 없이도 한번에 기능을 교체하게 해줌  

### 통합과 관련된 여러 방한 정리   
- 데이터베이스 통합은 최대한 피할 것  
- REST와 RPC의 장단점을 이해하고 요청/응답을 통합하는 좋은 출발점으로 REST를 고려  
- 오케스트레이션보다는 코레오그래피를 우선  
- 포스텔의 법칙을 이해하고 관대한 독자 패턴을 사용해서 호환성을 깨트리는 변경과 불필요한 버전을 피할 것  
- 구성 꼐층으로서의 사용자 인터페이스를 고려  


---  


**callback**    
다른 코드의 인수로 넘겨주는 실행 가능한 코드  
콜백을 넘겨받는 코드는 이 콜백을 필요에 따라 즉시 실행할 수도 있고 나중에 실행할 수도 있음  

**원격 프로시저 호출(remote procedure call/RPC)**  
local call을 통해 원격 서비스를 실행하는 기술   

**load balancer**   
부하 분산기  

**payload**  
전송의 근본적인 목적이 되는 데이터의 일부분으로, 해당 데이터와 함께 전송되는 헤더와 메타데이터 등의 데이터는 제외  

**handshake**  
두 개체간의 정상 통신 전에 통신 채널의 파라미터를 설정하는 자동화된 협상 과정  

**tolerant reader pattern/관대한 독자 패턴**   
서비스 디자인 패턴 중의 하나  
서비스 공급자가 제공한 메시지 포맷은 변경될 수 있음을 염두에 두고 메시지의 필요한 데이터만 추출하며 관련 없는 데이터는 무시해서 변경 결함을 피하게 함  

**RabbitMQ**  
AMQP 프로토콜을 구현한 오픈 소스 메시지 중개자 소프트웨어  
얼랭 언어 기반으로 구현하여 클러스터링 등의 고급 기술과 다양한 언어의 클라이언트 라이브러리를 지원  

**Competing Consumer pattern**   
메시지를 위해 경쟁하는 다수의 작업자 인스턴스를 다루는 방법을 기술   

**bootstrapping**   
일반적으로 컴퓨터의 전원이 켜지거나 리셋된 후 외부 입력 없이 기본 소프트웨어를 메모리에 로드하여 독립 수행하는 과정  

<ol>
  <li id="fn1">
    <p>다양한 REST 방식을 비교한 Richardson Maturity Model을 참고 <a href="#fnref1">↩</a></p>
  </li>
  <li id="fn2">
    <p>동일하게 반복되는 요청에 결과가 달라지지 않는 성질 <a href="#fnref2">↩</a></p>
  </li>
</ol>   

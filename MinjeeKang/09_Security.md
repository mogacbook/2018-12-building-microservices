보안
=====
>> 애드워드 스노든의 폭로 사건은 회사가 보유한 데이터의 가치와 우리가 구축한 시스템에 저장된 고객 데이터의 가치에 대한 인식을 높혀주었다. <br/>
>> 이 장에서는 시스템을 설계할 때 고려해야 할 보안적 측면을 간략히 설명한다.
<br/>

## 인증과 권한부여
>> 인증 : 자신이라고 말하는 당사자를 확인하는 과정, 일반적으로 사용자 이름과 비밀번호를 통해 사용자를 인증<br/>
>> 권한 주체 : 일반적으로 인증되는 사람 또는 사물에 대해 추상적으로 말하는 그 대상<br/>
>> 권한 부여 : 권한 주체를 허용된 행위와 매핑하는 매커니즘 (예: 그 사람이 할 수 있는 것과 없는 것을 결정하기 위해 시스템이 사용할 수 있는 일부 정보인 그 사람의 근무부서나 사무실의 정보를 전달받음)
>> 
__1. 일반적인 SSO 구현체__<br/>
-> 인증과 권한부여에 대한 일반적인 접근 방법은 싱글 사이온(sso) 솔루션을 사용하는 것, 대표적인 구현체인 SAML과 OpenID Connect는 이 분야를 위한 기능 제공<br/>
1> 권한주체가 웹 기반의 인터페이스를 통해 리소스에 접근 시, 그 사람은 인증을 위해 신원제공자에 재전송<br/>
2> 신원 제공자는 그 사람에게 사용자 이름, 비밀번호를 요구하거나 이중 요소 인증과 같은 것을 요구할 수 있음<br/>
3> 신원 제공자는 권한주체의 인증이 충족되면 그 사람의 자원 접근 허용 여부를 결정하도록 서비스 제공자에 정보전달<br/>
SAML - SOAP 기반의 표준이며 지원 가능한 라이브러리와 도구가 있음에도 불구, 작업이 꽤 복잡하기로 유명<br/>
OpenID Connect - OAuth 2.0의 특정 구현에서 출발한 표준이며 구글 및 다른 업체에서는 SSO를 처리하는데 사용, 더 단순한 REST 호출을 사용하고 사용 편의성이 향상되어 기업 시장으로 진출할 것으로 생각되나 신원 제공자의 부족은 가장 큰 장애물<br/>
__2. 싱글 시안은 게이트웨이__<br/>
마이크로서비스의 설정 내부에서 각 서비스는 신원 제공자를 경유, 핸드쉐이킹을 결정할 수 있지만 여기에는 분명히 중복된 작업이 많을 것이다. <br/>
모든 서비스가 신원 제공자에 대한 핸드셰이킹을 각각 처리하는 것보다 서비스와 외부 세상 사이에서 프록시처럼 동작하는 게이트웨이를 사용할 수 있다. 이 것은 사용자 재전송을 위한 행위를 한 고으로 모아 핸드셰이킹을 수행하는 것이다<br/>
문제점 1) 하위 서비스가 사용자 이름, 역할 같은 권한주체의 정보를 전달하는 방법에 대한 문제를 해결해야 함 2) 인증의 책임을 게이트웨이에 위임하기로 결정했다면 서로 격리된 마이크로서비스가 어떻게 행동할지를 추론하기가 어려워 짐 3) 모든 단계에 대한 보안 조치를 게이트웨이에 의지할 경우 단일 장재 지점이 있을 때 문제 발생
__3. 세분화된 권한 부여__<br/>
게이트웨이는 상당히 효과적인 큰 단위의 인증 기능을 제공하는 것이 가능<br/>
예) 로그인이 안 된 사용자의 헬프데스크 애플리케이션에 대한 접근 차단
*****
<br/>

## 서비스 대 서비스 인증과 권한부여
프로그램과 서비스가 서로 인증하려면...?
1. 경계 안의 모든 것 허용하기<br/>
특정 경계 내부의 모든 호출을 암묵적으로 신뢰한다고 가정<br/>
-> 일부 조직은 조직의 네트워크 경계선에서 보안을 보장하려 하기 때문에 두 서비스가 서로 통신할 때는 추가로 할 일이 없다고 생각하나 공격자가 네트워크에 침입한다면 전형적인 중간자 공격에 대해 무방비 상태일 것<br/>
조직에서 본 경계 내부를 신뢰하는 가장 일반적인 형태이며 이 트래픽을 HTTPS를 통해 전송할 것은 결정하지만 그 외의 다른 결정은 하지 않음<br/>
-> 이 모델을 사용하는 대부분의 조직에서는 이러한 암묵적인 신뢰 모델이 위험성을 인식한 결정이 아니라 애초에 위험성을 인식하지 않았다는 것이 문제!!!
2. HTTP(S) 기본 인증<br/>
-> 크라이언트가 사용자 이름과 패스워드를 표준 HTTP 헤더에 넣어서 전송, 서버는 상세 내용을 확인하고 클라이언트의 서비스 접근 허용 여부 승인<br/>
네트워크의 어떤 중간자도 헤더 정보와 데이터를 볼 수 있으므로 HTTP 기본인증은 대개 HTTPS 상에서 수행되어야 함<br/>
문제 1) 서버는 자신의 SSL인증서를 관리해야 하는데, 서버가 여러 머신을 관리하는 상황이라면 문제가 될 수 있음 2) SSL을 통해 전송된 트래픽은 바니쉬나 스퀴드 같은 리버스 프록시에 의해 캐시될 수 없음 3) 사용자 이름, 패스워드가 서비스 내부에서 저장될 수 있지만 동작을 복제될 위험이 있음<br/>
유의사항 - 이 접근 방식에서 서버가 아느 ㄴ것은 클라이언트 사용자 이름, 패스워드 뿐이기 때문에 네트워크 상의 어떤 대상으로부터 유입될 수 있으므로 우리가 기대하는 머신에서 온 것인지 알 수 없음
3. SAML 또는 OpenID Connect 사용하기<br/>
클라이언트는 신원 제공자에 자신을 인증하는 데 사용되는 일련의 자격증명을 가지고 있으며 서비스는 세부 인증을 결정하기 위해 필요한 정보를 얻는다 -> 서비스 계정이라 불리는 클라이언트를 위한 계정이 필요하다는 것을 의미<br/>
서비스 계정을 생성하려 한다면 사용 범위를 줄이고 각 마이크로서비스가 자신의 자격증명 셋을 보유하는 것을 고려 -> 자격증명이 누출디더라도 영향을 받은 자격증명 셋만 폐기하면 되기 때문에 자격증명 폐기와 변경을 쉽게 할 수 있음<br/>
문제 1) 기본 인증과 마찬가지로 자격 증명을 안전하게 저장해야 한다 2) 인증 분야의 일부 기술을 코드로 작성하는 것은 까다로운 일이다
4. 클라이언트 인증서<br/>
클라이언트 신원 확인을 위핸 또 다른 방법은 클라이언트 인증서 형태의 전송 계층 보안을 이용하는 것 - 클라이언트와 서버의 연결을 체결할 때 사용되는 X.509 인증서가 각 클라이언트에 설치되어 있으며 서버는 클라이언트 인증서의 진위를 검증, 유효한 클라이언트인지 확실히 보장할 수 있음
5. HTTP 기반의 HMAC<br/>
사용자 이름, 패스워드가 누출되는게 걱정이라면 HTTP 기본 인증은 현명한 선택이 아님<br/>
HTTPS 가 전통적인 대안이나 단점이 많음 - 인증서 관리, HTTPS 트래픽으로 인한 서버 부담 및 트래픽 캐시하기도 쉽지 않음<br/>
다른 대안 - 해시 기반 메시징 코드(HMAC)를 HTTP 요청의 서명에 사용하는 것<br/>
6. API 키<br/>
모든 공개 API는 API키를 사용 -> API 키르 ㄹ통해 서비스는 API 호출자를 인식할 수 있고 호출자의 능력에 제한을 둘 수 있다. 이러한 제한은 단순히 자원에 대한 접근 통제를 넘어 다른 조치로 확장 될 수 있음. <br/>
예) 모두를 위한 서비스 품질을 유지하기 위해 특정 호출자에 대한 속도 제한<br/>
SAML 핸드셰이킹의 처리와 비교, API 키 기반의 인증은 훨신 더 단순/직관적<br/>
7. 대리인 문제<br/>
혼동된 대리인 문제 - 서비스 대 서비스 통신에서 악의적인 당사자가 대리인 서비스를 속여 하위 서비스에 대한 인가되지 않은 호출을 하는 취약점의 한 형태
*****
<br/>

## 보관 중인 데이터 보호하기
1. 잘 알려진 것을 사용하라
2. 키가 전부다
3. 암호화 대상 정하기
4. 요구형 복호화
5. 백업 암호화하기
*****
<br/>

## 심층방어
1. 방어형
2. 로깅
3. 침입 방지와 방지 시스템
4. 네트워크 분리(망 분리)
5. 운영체제
*****
<br/>

## 시범예제
*****
<br/>

## 절약하라
*****
<br/>

## 인적 요소
*****
<br/>

## 황금률
*****
<br/>

## 보안 탑재
*****
<br/>

## 외부 검증
*****
<br/>

## 마치며
*****
<br/>




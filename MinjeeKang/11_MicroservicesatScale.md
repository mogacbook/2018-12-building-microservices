대규모 마이크로서비스
=====

### 장애는 어디에서나 발생한다
>>어떤 장애든 결국 발생한다는 것을 가정하여 장애에 대한 계획을 세운다면 다양한 절충안을 준비할 수 있다.
***
<br/>

### 얼마나 많아야 너무 많은 건가?
부하와 장애를 더 잘 처리하기 위해 시스템 확장 방법을 고려한다면 다음 요구사항을 이해하는 것에서 출발하라
- 응답시간/지연시간
- 가용성
- 데이터의 내구성
***                          
<br/>

### 기능 분해
>>회복력 있는 시스템 구축에서 가장 중요한 중 하나는 안전하게 기능을 분해할 수 있는 능력(특히 동작 또는 다운 중일 수 있는 다양하고 수많은 마이크로서비스에 기능이 확산되어 있을 때)

교차기능 요구 사항의 관점에서 개별 기능의 심각도를 생각함으로써 우리가 무엇을 할 수 있는지 훨씬 더 잘 알게 될 것<br/>
장애가 발생할 때 우아하게 처리할 수 있도록 기술적인 관점에서 가능한 일들을 고려

***
<br/>

### 아키텍처 안전 조치
무언가 잘못될 때 벌어지는 심각한 파급 효과를 막기 위해 이용하는 몇 가지 패턴 통칭
>> 나쁜 시민 한 명이 시스템 세상 전체를 망가뜨리지 않도록 시스템에 표준화를 강력히 고려해야 한다.
***
<br/>

### 안티프래질 조직
#### 타임아웃
#### 회로 차단기
#### 격벽
#### 격리
***
<br/>

### 멱등성
***
<br/>

### 확장
#### 더 크게 만들기
#### 작업부하 나누기
#### 위험 분산
#### 부하 분산
#### 작업자 기반 시스템
#### 다시 시작하기
***
<br/>

### 데이터베이스 확장
#### 서비스의 가용성과 데이터의 내구성
#### 읽기용 확장
#### 쓰기용 확장
#### 공유 데이터베이스 인프라스트럭처
#### CQRS
***
<br/>

### 캐싱
#### 클라이언트 측, 프록시, 그리고 서버 측 캐싱
#### HTTP 캐싱
#### 쓰기용 캐싱
#### 회복성을 위한 캐싱
#### 원본 감추기
#### 단순화하라
#### 캐시 중독: 경계할 일화
***
<br/>

### 자동 확장
***
<br/>

### CAP 정리
#### 일관성 희생하기
#### 가용성 희생하기
#### 분할용인 희생하기?
#### AP 또는 CP?
#### 양자택일이 아니다
#### 그리고 현실세계
***
<br/>

### 서비스 발견
#### DNS
***
<br/>

### 동적 서비스 레지스트리
#### 주키퍼
#### 칸슬
#### 유레카
#### 직접 만들기
#### 사람을 잊지 마라!
***
<br/>

### 문서화 서비스
#### 스웨거
#### HAL과 HAL 브라우저
***
<br/>

### 자기 기술 시스템
***
<br/>

### 마치며
***
<br/>

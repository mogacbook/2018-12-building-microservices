7장 테스팅
=====
세분화된 시스템의 테스팅과 관련된 문제를 해결, 새로운 기능을 자신있게 릴리스할 수 있는 몇가지 해결책 제시
> 수행 가능한 테스트의 종류를 이해하는 것은 대항하는 두 세력, 즉 소프트웨어를 가능한 한 빨리 실환경에 적용하려는 세력과 소프트웨어의 충분한 품질을 보장하려는 세력 사이의 균형을 유지하기 위해 중요하다

<br/>

### 테스트의 종류
![Agile Testing Quadrants](./image/111.png) <br />
성능 테스트 및 단위 테스트<br/>
-> 기술 중심의 테스트 / 일반적으로 모두 자동화<br/>
인수테스팅 및 탐색 테스트<br/>
-> UAT(고객에 의한 최종 제품 평가) 시스템 상 사용자 테스팅으로 대표되는 수동 테스팅<br/>
> 시스템을 테스트하는 방법의 측면에서 여러 선택을 해야함<br/>
> 최근 추세는 가능한 많은 자동화를 추구해 대규모 수동 테스트를 탈피 하는 것

현재 대규모 수동 테스트를 수행한다면 마이크로서비스의 길에 더 진입하기 전에 그 문제부터 해결하라고 제안, 소프트웨어를 신속하고 효율적으로 검사할 수 없다면 마이크로서비스가 주는 혜택을 누리지 못하기 때문
***
<br/>

### 테스트의 범위
![testpyramid](./image/02.png) <br />
1. 단위 테스트 <br />
일반적으로 단일 함수 또는 메서드 호출을 테스트<br />
테스트 주도 설계(TDD)의 부산물로 생성된 테스트는 이 범주에 속함<br />
개발자를 돕는 테스트임으로 비즈니스 중심이 아닌 기술 중심<br />
__이 테스트의 핵심목표는 기능의 정상 동작 유무에 대한 매우 빠른 피드백<br />__
__작업을 진행하면서 코드를 재구성하게 해주며, 작은 범위의 테스트들이 우리의 실수를 잡아주기 때문에 코드의 리팩토링을 지원하는데 있어 중요__
2. 서비스 테스트<br />
사용자 인터페이스를 우회, 서비스들을 직접 테스트<br />
여러 서비스로 구성된 시스템에 대해 서비스 테스트는 개별 서비스 기능 테스트 가능<br />
__단위 테스트 보다 더 많은 범위를 다루기 때문에 테스트가 실패할 경우 어떤 부분이 장애를 만들었는지 단위 테스트보다 찾기 어려우나 서비스 세트느는 변경되는 부분이 훨씬 적으므로 넓은 범위 테스트보다 덜 취약__
3. 엔드 투 엔드 테스트<br />
시스템 전체에 대해 수행하는 테스트(테스트 피라미드에서는 UI)<br />
수많은 실환경 코드 테스팅을 포함하기 때문에 통과할 경우 실환경에서 잘 동작할 것이라는 강한 확신+안심<br />
4. 절충안<br />
피라미드 위로 올라갈수록 테스트한 기능이 제대로 동작한다는 확신이 커지면서 테스트의 범위도 늘어남<br />
피라미드 아래로 내려가면 일반적으로 테스트가 훨씬 더 발라지므로 더 빠른 피드백을 얻을 수 있음<br />
__서비스 테스트 또는 엔드 투 엔드 테스트와 같으 ㄴ넓은 범위의 테스트가 실패하면 우리는 그 문제를 발견할 수 있는 빠른 단위 테스트를 작성할 것이다. 이와 같이 피드백 주기를 향상시키도록 지속적으로 노력할 것이다__
5. 얼마나 많은 테스트가 필요할까?<br />
다양한 종류의 자동화 테스타가 있으며 현재 테스트 수가 문제가 될 수 있음을 이해하는 것이 중요<br />
* 참고
안티패턴은 테스트 아이스크림콘이나 역피라미드로 언급<br />
작은 범위의 테스트가 거의 없고 대부분 큰 범위의 테스트<br />
프로젝트들으 ㄴ빙하처럼 느린 테스트와 아주 긴 피드백 주기를 가지며 테스트가 지속적 통합의 부분으로 수행된다면 많은 빈드를 할 수 없고 빌드 시간의 특성상 한번 빌드가 깨지면 오랜 시간 동안 중단된 채로 남을 수 있음
***
<br/>

### 서비스 테스트 구현하기
서비스 테스트는 전체 서비스에 걸친 한 기능의 단면에 대한 테스트를 원하지만 테스트하려는 서비스와 다른 서비스를 격리하기 위해 다른 협업자 모두를 스텁화하는 몇 가지 방법이 필요하다 <br />
-> 스텁 : 테스트 중인 시스템의 외부 이존성이나 협업자를 대처하는 모의 구현 의미, 다른 컴포넌트와의 로직을 독립적으로 검증
> 서비스 테스트 집합은 하위 협업자를 위한 스텁 서비스를 실행시키여하고 스텁 서비스들과의 연결되는 환경에 고객 서비스를 구성해야 한다. 그런 다음 실환경 서비스를 모방해 응답을 보내도록 스텁을 구성해야 한다.
1. 목 또는 스텁 사용하기
하위 협업자의 스텁 생성을 이야기할 때는 테스트 대상의 서비스가 알려진 요청을 보내면 정해진 응답을 하는 스텁 서비스 생성을 의미 <br />
이 테스트의 변형은 스텁 대신 목(MOCK)을 사용하는 것 <br />
목을 사용할 때는 호출의 수행까지 보장(예상된 호출이 이루어지지 않으면 테스트는 실패) / 목은 예상된 부작용이 발생하는지 확인하는데 유용<br />
스텁과 목 호출 사이 균형은 민감한 것이라 단위 테스트처럼 서비스 테스트에서도 까다롭기 때문에 일반적으로 서비스 테스트들을 위해 목보다 스텁을 사용
2. 더 영리한 스텁 서비스<br />
스텁/목 서버를 통해 많은 업무를 줄일 수 있음
***
<br/>

### 까다로운 엔드 투 엔드 테스트
엔드 투 엔드 테스트의 목표는 시스템의 전체적인 관점을 제공하기 위해 사용자 인터페이스를 통해 시스템의 하부 모든 기능을 동작 시키는 것<br/>
-> 엔드 투 엔드 테스트를 구현하기 위해 다수의 서비스를 함께 배포, 그 후에 모든 서비스에 대한 테스트를 수행해야 함<br/>
-> 훨씬 많은 범위를 다루고 시스템 작동에 대해 많은 확신을 갖게 하지만<br/>
이 테스트는 느리고 실패를 분석하기 어렵다<br/>
> 여러 서비스의 파이프라인을 단일 엔드 투 엔드 테스트 단계로 수렴하여 서비스들의 새로운 빌드가 발생될 때마다 엔드 투 엔드 테스트를 수행<br/>
> 서비스가 변경되면 언제라도 그 서비스에 대한 로컬 테스트를 수행, 그 테스트들이 통과되면 통합 테스트를 시작할 것이다.
***
<br/>

### 엔드 투 엔드 테스팅의 단점 / 신뢰할 수 없고 취약한 테스트
변경되는 부분이 많을수록 테스트는 더 취약해지고 비결정적이 되며 가끔 실패하지만 재실행하면 성공하는 테스트는 실뢰할 수 없는 테스트다 <br/>
신뢰할 수 없는 테스트를 감지할 때는 최선을 다해 그 것을 업애는 것이 중요, 그렇지 않다면 항상 그런식으로 실패한느 테스트 집합 때문에 믿음을 잃기 시작
> 신뢰할 수 없는 테스트를 가진 테스트 집합을 다이안 보건의 __비정상의 정상화__, 즉 시간이 지나면서 정상이며 문제가 아니라고 받아들이기 시작한 잘못에 우리가 매우 익숙해질 수 있다는 개념의 희생자가 될 수 있다.
1. 누가 이 테스트를 작성하는가?<br/>
엔드 투 엔드 테스트 집합을 공동 소유의 공용 코드 베이스로 다루는 것이 최고의 균형<br/>
팀들은 여기에 자유롭게 체크인하지만 테스트 집합의 건강 상태에 대한 책임은 서비스를 직접 개발한 팀 사이에 공유되어야 함
2. 얼마나 오래 걸릴까?<br/>
엔드 투 엔드 테스트는 시간이 좀 필요한데 이러한 느림은 종종 이들 테스트를 신뢰할 수 없다는 사실과 함께 중대한 문제가 될 수 있음<br/>
따라서 테스트를 병렬로 실행, 문제 일부를 개선할 수 있음
3. 엄청난 적체<br/>
모든 테스트를 성공적으로 통과한 소프트웨어만 배포한다면 실환경에 배포될 수 있는 서비스가 매우 적어진다는 것을 의미, 즉 여기서 적체가 발생<br/>
배포의 범위가 넓어지고 릴리스의 위험도가 높아질수록 문제를 만들어 낼 가능성 또한 높아져 소프트웨어를 자주 릴리스할 수 있는 주요 원동력은 작은 변경이 준비되는대로 릴리스 한다는 생각에 기반을 둔다
4. 메타버전<br/>
여러 서비스에 적용된 변경들을 함께 버전 관리함으로써 우리는 그 서비스들의 변경, 배포가 동시에 가능하다는 아이디어를 효과적으로 받아드리나 이는 마이크로서비스의 주요 혜택인 서비스를 다른 서비스와 독립적으로 배포하는 능력을 잃어버리게 함
***
<br/>

### 스토리가 아닌 테스트 여정
앞의 단점에도 불구, 많은 사용자들에게는 엔드 투 엔드 테스트는 한두 개 서비스를 여전히 관리할 수 있고 여전히 합당한 선택<br/>
그러나 서비스의 수가 많다면 테스트 집합은 아주 빠른 속도로 엄청나게 비대해지고 최악의 경우 테스트 중인 시나리오는 곱집합 처럼 폭팔적으로 증가
> 해결방안...<br/>
> 전체 시스템을 테스트하는 소수의 핵심 여정에 집중하는 것<br/>
> 핵심 여정에서 다뤄지지 않는 기능은 개별 서비스의 테스트에서 다루어져야 함<br/>
> 이 여정은 상호 합의되어야 하고 공동소유여야 함
***
<br/>

### 우리를 구할 소비자 주도 테스트
소비자 주도 계약(CDC) - 실제 소비자에 대한 테스트 없이 할 수 있는 방법<br/>
>CDC를 통해 서비스에 대한 소비자 기대 사항을 정의, 테스트 코드 형태로 표현하여 해당 테스트는 생산자에 대해 수행 <br/>
>CDC 중 하나라도 깨질 경우 절대 배포되지 않도록 생상자의 CI 빌드 일부분으로 수행<br/>
>테스트의 피드백 관점에서 매우 중요한 점은 이들 테스트는 하나의 생산자만 격리, 수행 해야함
1. 팩트<br/>
베스 스커리가 개발한 소비자 주도 테스팅 도구<br/>
소비자는 루비DSL을 사용, 생산자에 대한 기대사항을 정의 > 로컬 목 서버 실행 > 팩트 명세서 파일을 생성하기 위해 그 서버에서 기대 사항 실행 <br/>
팩티 파일은 JSON 형식의 명세서로 직접 작성하거나 언어 API사용(이 편이 훨씬 쉽다)<br/>
생산자 측면에서는 JSON 팩티 명세서 이용, 소비자 명세서가 생산자의 API를 호출하고 응답하는지 검증<br/>
중립적인 JSON 명세서의 사용 좋은 아이디어이다 -> 루비 클라이언트를 이용, 소비자 명세서를 생성할 수 있고 팩트의 JVM 포팅버전을 사용하여 자바 생산자를 검증할 수 있다는 것을 의미
2. 대화에 관하여<br/>
애자일에서 스토리는 CDC처럼 대화의 표식(placeholder)으로 흔히 언급<br/>
스토리는 서비스 API가 어떻게 보여야 하는지에 대하 논의를 체계화<br/>
스토리가 망가질 때 API를 어떻게 개선해야 하는지 이야기 할 시발점이 됨
***
<br/>

### 출시 후의 테스팅
대부분의 테스팅은 시스템이 실환경 배포 전 완료되나 테스트 모델이 완벽하지 않다면 시스템이 격한 상황일 때 문제가 드러남. <br/>
-> 대응 방법으로는 더 많은 문제를 사전에 발견, 운영 중인 실환경 시스템에 맞닥뜨릴 문제를 줄이기 위해 더 많은 테스트를 정의하고 모델을 다듬는 것
1. 배포를 리리스와 분리하기<br/>
문제 발생 전 더 많이 찾아내기 위한 한 가지 방법은 __테스트를 수행할 단계를 전통적인 배포 전 단계를 넘어 확장하는 것__<br/>
방법1) 스모크테스트 - 제대로 배포되었는지 보장하기 위해 새롭게 배포된 소프트웨어에 대해 수행하도록 설계된 테스트의 집합 (지역적 환경 문제 발견 시 도움)<br/>
방법2) __청색/녹색 배포__ - 동시에 배포된 두 개의 소프트웨어 복제본 중에서 한 버전만 실제 요청 처리<br/>
** 청색/녹색 배포 구현 시 필요한 점 : 1) 실환경 트래픽을 다른 호스트로 향하게 할 수 있어야 함 2) 한번에 두 버전의 마이크로서비스를 프로비저닝 할 수 있어야 함
2. 카나리아 릴리스<br/>
청색/녹색 배포와 혼동되는 기술로 버전들을 더 오래 공존시킬 수 있고 트래픽의 양을 자주 변경할 수 있다는 차이가 있음<br/>
예시) 넥플릭스는 릴리스에 앞서 실환경과 동일한 버전을 가지는 베이스라인 클러스터에 새로운 서비스 버전과 함께 배포, 수 시간 동안 새 버전과 베이스라인 버전 클러스터 양쪽에 실환경의 부하 일부를 주면서 측정, 카나리아 릴리스가 테스트를 통과하고 나면 실환경으로 전체 전개 진행<br/>
고려할 점 - 실환경 요청의 일정 부분을 카나리아 릴리스로 우회할지, 복제할 것인지 결정 필요<br/>
__나쁘 릴리스의 출시 위험을 관리할 도구를 제공, 실제 트래픽으로 새 버전의 소프트웨어를 검증할 수 있게 한다. 하지만 청색/녹색 배포보다 복잡한 설정과 약간의 사고를 더 필요로 함, 또한 더 많은 하드웨어를 점유할 수 있음, 더불어 트래픽 비율 조정을 위해 더 정교한 트래픽 라우팅도 필요__
3. MTBF 보다 MTTR?<br/>
자동하된 기능 테스트를 추가하는 것보다 릴리스를 보수하는데 같은 노력을 쏟는 것이 훨씬 유익할 수 있다 -> 웹 운영 분야에서는 이 것은 대개 __평균 무고장 시간(MTBF)__과 __평균수리시간(MTTR)__ 사이의 최적화에 대한 균형으로 언급<br/>
다양한 조직에서 MTBF, MTTR 사이의 균형점은 다르며 균형점 대부분은 실환경에서 장애의 실질적 영향에 대한 이해와 함께 한다
***
<br/>

### 교차기능 테스트
비기능적 요구사항 - 일반적인 기능과 같이 단순히 구현될 수 없는 시스템의 특징을 기술하는데 사용되는 포괄적 용어 <br/>
-> 사라 타라포레왈라는 교차기능 요구사항(CFR)이라는 용어를 고안<br/>
> CFR은 실제로 실환경에서만 충족될 수 있으며 이런 종류의 테스트는 속성 테스팅 분면에 속함<br/>
> CFR에 관한 테스트도 테스트 피라미드를 따라야하며 예를들어 엔드 투 엔드 부하 테스트에서 성능 병목점을 찾았다면 앞으로 그 문제를 신속히 발견할 더 작은 범위의 테스트를 작성하라<br/>
> CFR은 더 빠른 테스트에 적합
1. 성능 테스트<br/>
시스템의 핵심 기능을 확인하는 테스트부러 시작하라- 엔드 투 엔드 테스트를 규모에 맞게 쉽게 실행할 수 있을 것<br/>
테스트의 결과가 거짓 부정 또는 더 나쁜 경우 거짓 긍정 에러가 발생할 수 있음을 명심<br/>
성능 테스트의 수행에는 시간이 소요되므로 작은 집합은 매일, 큰 집합은 매주 수행하는 것이 일반적이며 정기적으로 수행할 것<br/>
결과를 꼭 확인하라<br/>
성능 테스트는 실제 시스템의 성능 모니터링을 지원받아 수행되어야 할 것
***
<br/>

### 마치며
* 빠른 피드백을 위해 최적화하고 테스트를 종류별로 적절히 분리하라
* 소비자 주도 계약을 이용, 가능한 어디서든지 엔드 투 엔드 테스트의 필요성을 줄여라
* 팀 간 대화의 초점을 맞추기 위해 소비자 주도 계약을 사용하라
* 테스팅에 더 많은 공을 들이는 것과 실환경에서 빠른 문제의 발견 사이의 절충점을 이해하도록 노력하라
***

# CHAPTER11. Microservices at Scale

## 장애는 어디에서나 발생한다.
- 장애는 대규모 환경에서 통계적으로 필연적이다.
- 어떤 것이든 고장날 수 있다는 가정을 명심하는 것은 문제의 해결 방법을 다르게 생각하도록 만든다.
- 어ㄸㄴ 장애든 결국 발생한다는 것을 염두에 두고 장애에 대한 계획을 세운다면 다양한 절충안을 준비할 수 있다.

## 얼마나 많아야 너무 많은 건가?
- 교차기능 요구 사항의 이해는 데이터의 내구성, 서비스의 가용성, 처리량, 서비스의 허용 지연시간 같은 측면을 모두 고려하는 것이다.
- 일반적인 교차기능 몇 가지를 정의하고 특별한 사용 사례를 위해 재정의하는 것을 권한다.
    - 응답시간/지연시간 : 다양한 연산은 얼마나 오래 걸려야 할까?
    - 가용성 : 서비스가 다운될 것을 예상하는가? 24/7의 연중무휴 서비스로 간주할 수 있는가?
    - 데이터의 내구성 : 얼마나 많은 데이터 손실이 허용 가능한가? 얼마나 오랜 기간 데이터를 보관해야 하는가?

## 기능 분해
- 회복력 있는 시스템 구축에서 가장 중요한 것 중 하나는 안전하게 기능을 분해할 수 있는 능력이다.
- 각 서비스의 장애로 인한 충격을 이해하고 기능을 적절히 분해하는 방법을 생각해야 한다.

## 아키텍처 안전 조치 (architectural safety measure)
- 무언가 잘못될 때 벌어지는 심각한 파급 효과를 막기 위해 이용하는 몇 가지 패턴을 통칭하여 아키텍처 안전 조치라고 부른다.

## 안티프래질 조직
- 넷플릭스는 장애에 강한 시스템을 보장하기 위해 실제로 장애를 조장하며 이를 극복했다. 장애를 만들고 그 장애에 대응하도록 구축함으로써 확장이 잘되고 고객의 요구도 잘 지원하는 시스템을 보장했다.
- 모든 것은 결국 고장나게 되어 있다. 분산된 아키텍처에서 발생할 수 있는 장애에 대응하기 위한 준비가 아주 중요하다.
- 타임아웃
    - 모든 프로세스 경계 외부의 호출에 타임아웃을 넣고 항상 기본 타임아웃 시간을 설정하라. 타임 아웃 발생 시간을 로깅하고 어떤 일이 발생했는지 살펴보며 타임아웃을 적절히 변경하라.
- 회로 차단기
    - 하위 자원이 다운되거나 타임아웃되거나 에러를 리턴할 때 특정 임계값에 도달한 후 자동적으로 전송 트래픽을 중지시키고 신속히 실패하도록 만든다. 그리고 정상으로 복구되었을 때 자동으로 재시작할 수 있다.
    - 회로 차단기와 마찬가지로 더 안전한 작업을 위해 수동으로 차단기를 사용할 수 있다.
- 격벽
    - 격벽은 장애를 격리하기 위한 방법으로 선박에서의 격벽은 배의 나머지 부분을 보호하기 위해 밀봉 역할을 하는 선체의 벽을 말한다. 배에 물이 새기 시작하면 격벽의 문을 닫아 배의 일부는 잃게 되더라도 나머지 부분을 구할 수 있다.
    - 얽혀 있는 기능을 분리된 마이크로서비스로 분해함으로써 한 지역의 장애가 다른 지역에 영향을 줄 가능성을 줄인다.
    - 회로 차단기를 격벽을 밀봉하는 자동 메커니즘으로 간주할 수 있다. 
    - 타임아웃과 회로 차단기는 리소스가 제한될 때 그것을 확보하는 데 도움이 되지만 격벽은 처음부터 리소스가 제한되지 않게 할 수 있다.
- 격리
    - 서비스 간의 격리도를 높이면 서비스 소유자 간에 조율할 것도 줄어든다. 팀 간 조율이 적어질수록 더 자유롭게 서비스를 운영하고 발전시킬 수 있기 때문에 팀의 자율성은 더 높아진다.

## 멱등성
- 연산이 연속적으로 여러 번 적용되더라도 첫 적용 후의 결과가 달라지지 않는 성질의 연상을 멱등 연산이라고 한다. 연산이 멱등적이라는 것은 역효과없이 호출이 반복할 수 있음을 의미한다.
- 에러를 복구하는 일반적인 방법으로 처리가 확실하지 않은 메세지를 재생할 때 매우 유용하다.

## 확장
- 시스템 확장의 이유 
    - 장애에 더 잘 대응하기 위해
    - 성능을 위해
- 더 크게 만들기
    - 수직 확장(vertical scaling)으로 알려진 확장 형태는 고비용이다. 
    - 한 대의 서버만 있을 경우 서버의 탄력성이 크게 향상되지 않는다.
    - 빠르고 좋은 해결방안이며 특히 머신 크기를 쉽게 변경할 수 있는 가상화 제공자를 사용중이라면 더욱 그렇다.
- 작업부하 나누기
- 위험 분산
- 부하 분산
- 작업자 기반 시스템
    - 작업자 기반 시스템에서는 비록 작업자 자체가 신뢰성이 높을 필요가 없더라고 그 작업을 완료해야하는 시스템은 신뢰성이 있어야한다.
- 다시 시작하기
    - 재설계는 동기식 요청과 응답을 이벤트 기반의 시스템으로 전환하거나, 새로운 배포 플랫폼을 적용하거나, 전체 기술 스택을 교체하거나 그 중간에 있는 모든 것을 의미할 수도 있다.
    - 확장하기 위해 시스템을 변경할 필요가 있다면 이것은 실패가 아닌 바로 성공의 징조다.

## 데이터베이스 확장
- 서비스의 가용성과 데이터의 내구성
    - 대기(standby) 모델 :주 데이터베이스가 다운될 경우 대기 복제 데이터베이스가 있어 안전하지만, 주 데이터베이스를 백업으로 바꾸거나 복제데이터베이스를 주 데이터베이스로 승격시키는 메커니즘 없이는 데이터베이스의 가용성을 얻을 수 없다.
- 읽기용 확장
    - 데이터의 캐싱은 큰 역할을 한다.
    -  읽기 복제(read replica) 모델 : 주 데이터베이스로부터 복제 데이터베이스로의 복제는 쓰기 수행 후 특정 시점에 수행된다. 이 기술은 가끔은 복제가 완료되기 전까지 이전 데이터 (stale data)를 보게 될 수 있다는 것을 의미한다. 하지만 결국엔 주 데이터베이스와 일치된 데이터를 읽게 되는데 이를 최종적으로 일관성을 유지하는 상태(eventaully consistent) 라고 한다.
- 쓰기용 확장
    - 샤딩 (sharing) 
        - 같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 방법을 의미한다.
        - 많은 노드를 가질 수 있다.
        - 질의를 처리할때 복잡하다.
        - 기존 클러스터에 샤드를 추가할 때 까다롭다.
        - 쓰기용 샤딩은 쓰기 볼륨을 확장할 수 있지만 회복성을 향상시키는 것은 아니다.
- 공유 데이터베이스 인프라스트럭처
    - 필요한 머신의 수를 줄일 수 있다는 점에서 유용하지만 명백한 단일 장애 지점이 된다. 
- CQRS 
    - 명령과 질의에 대한 책임 분리 (Commend-Query Responsibility Segregation) 패턴
    - 정보를 저장하고 질의하기 위한 대안 모델
    - 시스템 일부가 명령을 처리해서 상태를 변경하는 요청을 캡처하며 시스템의 다른 부분이 질의를 처리한다.

## 캐싱
- 일반적으로 사용되는 성능 최적화 방법으로, 연산의 이전 결과를 저장해서 연속된 요청은 재연산을 위한 시간과 자원의 소비 없이 저장되어 있는 값을 사용할 수 있다.
- 클러이언트 측, 프록시, 그리고 서버 측 캐싱
    - 클라이언트 측 캐싱 
        - 클라이언트가 캐싱된 결과를 저장하는 것이다. 하위 서비스가 힌트를 제공하며 클라이언트는 그 응답을 통해 해야 할 것을 이해하고 새로운 요청의 시점과 여부를 알  수 있다.
        - 네트워크 호출을 대폭 줄이고 서버 하위 서비스에 대한 부하를 줄일 수 있다.
    - 프록시 캐싱 
        - 클라이 언트와 서버 사이에 프록시를 배치하는 것이다. 예로는 리버스 프록시, CDN
        - 기존 시스템에 캐싱을 추가하는 가장 간단한 방법이다.
        - 클라이언트와 서버 사이의 프록시 배치는 부가적인 네트워크 홉을 추가한다.
    - 서버 측 캐싱 
        -  서버가 캐싱의 책임을 지고 레디스, 멤캐시드 또는 단순한 인메모리 캐시 같은 시스템을 활용한다.
        - 데이터의 무효화 또는 캐시 적중률 추적과 최적화 같은 것을 추측하기 쉽다.
- HTTP의 캐싱
    - HTTP는 클라이언트와 서버측에서 캐시할 수 있는 유용한 규약(컨트롤)을 제공한다.
- 쓰기용 캐싱
    - 대량 쓰기를 할 때나 동일한 데이터를 여러번 쓸 때 유용하다.
- 회복성을 위한 캐싱
    - 장애의 회복성을 구현하는 데 사용될 수 있다.
- 원본 감추기
    - 시스템의 안정성을 위해 사용한다.
- 단순화 하라
    - 너무 많은 곳에 캐싱하는 것을 주의해야 한다. 다수의 서비스가 호출 체인으로 연결되어 있는 마이크로서비스 아키텍처에서 특히 문제가 될 수 있다.

## CAP 정리
- 우리는 실패 모드에서 두 가지를 취하게 된다.
- 일관성(Consistency) : 다수의 노드로부터 동일한 대답을 얻어야 한다는 시스템 특성이다.
- 가용성(Availability) : 모든 요청이 응답을 받는다는 것을 의미한다.
- 분할용인(Partition tolerance) : 시스템 부분 간의 통신이 가끔씩 실패한다는 사실을 다루는 시스템의 능력을 의미한다.

## 동적 서비스 레지스트리
- 주키퍼 : 클러스터의 여러 노드를 실행해서 다양한 보장을 제공한다. 노드 간에 안전하게 데이터를 복제하고 노드가 실패할 때 일관성을 유지하는 것을 보장한다.
- 칸슬 : 환경 구성 관리와 서비스 발견 모두 지원한다. 노드의 상태 확인을 수행하는 기능처럼 유용한 다른 기능도 구축한다. 서비스의 등록, 키/값 저장소 질의 또는 상태 확인 삽입 등 모든 작업에 RESTful HTTP 인터페이스를 사용한다.
- 유레카 : 범용 환경 구성 저장소가 아니다. 서비스 인스턴스에 대한 기본적인 라운드 로빈 조회를 지원할 수 있다는 점에서 기본적인 부하 분산 기능도 제공한다. REST 기반의 엔드포인트를 제공하므로 자체 클라이언트나 자바 클라이언트도 작성할 수 있다.
- 직접 만들기
- 사람을 잊지 마라! 
    - 어떤 시스템을 선택하든 컴퓨터뿐만 아니라 인간을 위한 디스플레이를 만들기 위해 레지스트리 외에 리포트와 대시보드 도구가 있는지 확인하라.

## 문서화 서비스
- 스웨거 : API를 잘 기술하면 웹 브라우저를 통해 API 문서를 볼 수 있고 API와 상호 작용할 수 있는 웹 UI를 생성할 수 있다.
- HAL과 HAL 브라우저 

## 자기 기술 시스템
- 정보를 쉽게 이용하게 만드는 것은 대규모로 수행되는 시스템에서 발생할 새로운 복잡성을 관리하는 핵심 도구다.
